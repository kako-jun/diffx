# パフォーマンスベンチマーク

このドキュメントは `diffx` コア操作のパフォーマンスベンチマークと、パフォーマンス最適化のガイダンスを提供します。

## ベンチマーク結果

### 環境
- **プラットフォーム**: Ubuntu 22.04 (GitHub Actions ランナー)
- **CPU**: AMD EPYC 7763 (またはCI環境相当)
- **Rust**: 1.75+ with release optimizations
- **テスト日**: 2025年1月

### コア差分操作

| テストケース | データサイズ | 時間 | スループット |
|-------------|-------------|------|-------------|
| 小さなJSON | ~200バイト | **1.3µs** | ~150MB/s |
| 大きなJSON | ~25KB | **281µs** | ~89MB/s |

### 詳細結果

#### 小さなJSON差分
```
テストデータ: 5キー、配列、オブジェクトを含むネストされたJSON
時間: 1.3076µs - 1.3341µs (中央値: 1.32µs)
```

#### 大きなJSON差分  
```
テストデータ: 文字列値を持つ1000キーオブジェクト
時間: 272.26µs - 290.94µs (中央値: 281µs)
```

## パフォーマンス特性

### 時間計算量
- **オブジェクト比較**: O(n) ここで n = キー数
- **配列比較**: O(n×m) ここで n,m = 配列長
- **IDキー付き配列**: セマンティック追跡でO(n+m)
- **ネスト構造**: O(深度 × 要素数)

### メモリ使用量
- **小さなファイル (<1MB)**: ~入力サイズの2倍
- **大きなファイル (>10MB)**: ~入力サイズの1.5倍
- **ストリーミング**: 未実装（ファイル全体をロード）

## パフォーマンス回帰検出

### CI閾値
- **小さなJSON**: < 2.0µs (50%安全マージン)
- **大きなJSON**: < 500µs (75%安全マージン)

### 監視
- **GitHub Actions**: 全PR/プッシュで自動実行
- **週次実行**: 長期追跡のため日曜日午前2時UTC
- **アラート**: 閾値超過時の自動失敗

## 最適化ガイドライン

### 最大パフォーマンスのために

1. **適切な形式を使用**
   ```bash
   # 最速: バイナリJSONフォーマット
   diffx data1.json data2.json
   
   # 低速: 複雑なネストされたYAML
   diffx complex1.yaml complex2.yaml
   ```

2. **配列比較の最適化**
   ```bash
   # 効率的: IDベース比較を使用
   diffx users1.json users2.json --array-id-key id
   
   # 非効率: 大きな配列でのインデックスベース比較
   diffx large_array1.json large_array2.json
   ```

3. **早期フィルタリング**
   ```bash
   # 関連部分に比較を集中
   diffx config1.json config2.json --path "database"
   diffx data1.json data2.json --ignore-keys-regex "^(timestamp|_.*)"
   ```

### パフォーマンスオプション

```bash
# セマンティック配列比較
diffx file1.json file2.json --array-id-key id

# 内部フィールドをスキップ
diffx file1.json file2.json --ignore-keys-regex "^_.*"

# 効率的な浮動小数点比較  
diffx file1.json file2.json --epsilon 0.001
```

## 他のツールとの比較

| ツール | 小さなJSON | 大きなJSON | 機能 |
|-------|------------|------------|------|
| **diffx** | **1.3µs** | **281µs** | セマンティック、多形式 |
| 従来のdiff | ~2ms | ~50ms | テキストベース、フォーマット敏感 |
| jq + diff | ~5ms | ~100ms | JSONのみ、前処理が必要 |

### 利点
- 構造化データで**10-100倍高速**（テキストベースツール比）
- **形式非依存**: JSON/YAML/TOMLで同じパフォーマンス
- **セマンティック焦点**: 無関係なフォーマット差異を無視

## 実世界のパフォーマンス

### 典型的な使用ケース

1. **CI/CD設定検証** (1-10KBファイル)
   - 時間: < 10µs
   - 適用: リアルタイム検証

2. **APIスキーマ比較** (10-100KBファイル)  
   - 時間: < 1ms
   - 適用: 開発ワークフロー

3. **大きなデータファイル** (1-10MBファイル)
   - 時間: 10-100ms 
   - 適用: バッチ処理

4. **ディレクトリ比較** (100+ファイル)
   - 時間: サイズに応じて1-10秒
   - 適用: デプロイメント検証

### パフォーマンスのコツ

1. **バッチ操作**: 複数ファイルにはディレクトリ比較を使用
2. **並列処理**: CI/CDでは複数のdiffxインスタンスを実行可能
3. **早期フィルタリング**: `--path`を使用して変更セクションに焦点
4. **設定最適化**: データセット用に適切な`array_id_key`を設定

## 回帰テスト

### ローカルでのベンチマーク実行

```bash
# 完全ベンチマークスイートを実行
cargo bench --package diffx-core

# 簡単なパフォーマンスチェック
cargo build --release
time target/release/diffx large_file1.json large_file2.json
```

### 継続的監視

我々のCIパイプラインは自動的に：
- 全PRでベンチマークを実行
- ベースラインパフォーマンスと比較
- 50%以上の回帰でビルドを失敗
- 履歴追跡のため結果をアーカイブ

### 履歴パフォーマンス

以下で時間経過のパフォーマンスを追跡：
- GitHub Actionsアーティファクト
- Criterionベンチマークレポート
- リリースパフォーマンス要約

---

**注記**: ベンチマーク結果はハードウェア、システム負荷、データ特性によって変動する可能性があります。提供された数値はCI環境での典型的なパフォーマンスを表しています。